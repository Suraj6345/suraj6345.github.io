<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Particle Playground</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #00f2ff;
            --glass: rgba(20, 20, 25, 0.85);
            --border: rgba(255, 255, 255, 0.1);
            --text: #f0f0f0;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #050505;
            font-family: 'Inter', sans-serif;
            color: var(--text);
        }

        /* 3D Canvas */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Video Input - CRITICAL FIX: Opacity 0 instead of display:none */
        #input_video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            z-index: 0;
            opacity: 0; /* Hidden but active */
            transform: scaleX(-1);
            pointer-events: none;
        }

        /* Debug Canvas (Shows Skeleton) */
        #output_canvas {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            z-index: 2;
            border-radius: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.5);
            transform: scaleX(-1); /* Mirror to match user movement */
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
        }

        .panel {
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 20px;
            pointer-events: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 1.1rem;
            margin: 0 0 15px 0;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
            box-shadow: 0 0 8px #ff4444;
            transition: background 0.3s;
        }
        .status-dot.active { background: #00ff88; box-shadow: 0 0 8px #00ff88; }

        /* Controls */
        .control-group { margin-bottom: 15px; }
        .control-group label {
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(255,255,255,0.6);
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            height: 4px;
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        .shape-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .shape-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid transparent;
            color: #ccc;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        .shape-btn:hover { background: rgba(255,255,255,0.1); }
        .shape-btn.active {
            background: rgba(0, 242, 255, 0.15);
            border-color: var(--primary);
            color: var(--primary);
        }

        .btn-action {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: var(--primary);
            color: #000;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
        }
        .btn-action:hover { opacity: 0.9; }

        /* Loader */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Debug Label */
        .debug-label {
            position: absolute;
            bottom: 175px;
            right: 20px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            text-align: right;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 20px; font-size: 0.9rem;">Initializing Vision Models...</p>
    </div>

    <div id="ui-layer">
        <div class="panel">
            <h1>Particle Lab <div id="cam-status" class="status-dot" title="Camera Status"></div></h1>
            
            <div class="control-group">
                <label>Shape Template</label>
                <div class="shape-grid">
                    <button class="shape-btn active" data-shape="heart">Heart</button>
                    <button class="shape-btn" data-shape="flower">Flower</button>
                    <button class="shape-btn" data-shape="saturn">Saturn</button>
                    <button class="shape-btn" data-shape="buddha">Figure</button>
                    <button class="shape-btn" data-shape="sphere">Sphere</button>
                    <button class="shape-btn" data-shape="fireworks">Firework</button>
                </div>
            </div>

            <div class="control-group">
                <label>Color</label>
                <input type="color" id="color-picker" value="#00f2ff" style="width:100%; height:30px; border:none; cursor:pointer;">
            </div>

            <div class="control-group">
                <label>Particles: <span id="count-val">15k</span></label>
                <input type="range" id="particle-count" min="1000" max="30000" value="15000" step="1000">
            </div>

            <div class="control-group">
                <label>Motion Noise</label>
                <input type="range" id="noise-str" min="0" max="2" value="0.5" step="0.1">
            </div>

            <button class="btn-action" id="snap-btn">üì∏ Take Snapshot</button>

            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); margin-top: 15px; line-height: 1.4;">
                <strong>Controls:</strong><br>
                ‚úä <b>Fist:</b> Collapse / Shrink<br>
                üñê <b>Open Hand:</b> Expand / Explode<br>
                üëê <b>Two Hands:</b> Zoom In/Out
            </div>
        </div>
    </div>

    <div class="debug-label">Camera Tracking View</div>
    <div id="canvas-container"></div>
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        const config = {
            particleCount: 15000,
            baseColor: new THREE.Color('#00f2ff'),
            shape: 'heart',
            noiseStrength: 0.5,
            handsDetected: false,
            handDistance: 1.0, 
            handTension: 0.0,
            handX: 0,
            handY: 0
        };

        const container = document.getElementById('canvas-container');
        const videoElement = document.getElementById('input_video');
        const outCanvas = document.getElementById('output_canvas');
        const canvasCtx = outCanvas.getContext('2d');
        const loader = document.getElementById('loader');

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- SHADERS ---
        const vertexShader = `
            uniform float uTime;
            uniform float uSize;
            uniform float uMorph;
            uniform float uNoiseStr;
            uniform float uScale;
            uniform float uSpread;

            attribute vec3 targetPosition;
            attribute float pSize;

            varying vec3 vColor;
            varying float vDist;

            vec3 curlNoise(vec3 p) {
                float t = uTime * 0.5;
                return vec3(
                    sin(p.y * 0.5 + t) * cos(p.z * 0.3 + t),
                    sin(p.z * 0.5 + t) * cos(p.x * 0.3 + t),
                    sin(p.x * 0.5 + t) * cos(p.y * 0.3 + t)
                );
            }

            void main() {
                vec3 pos = mix(position, targetPosition, uMorph);
                vec3 noise = curlNoise(pos) * uNoiseStr;
                vec3 spreadDir = normalize(pos) * uSpread * 8.0;
                vec3 finalPos = (pos + noise + spreadDir) * uScale;
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = uSize * pSize * (300.0 / -mvPosition.z);
                vDist = length(finalPos);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor;
            varying float vDist;
            void main() {
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                if (dot(cxy, cxy) > 1.0) discard;
                float alpha = 1.0 - smoothstep(0.5, 1.0, length(cxy));
                gl_FragColor = vec4(uColor + (vDist * 0.02), alpha * 0.8);
            }
        `;

        // --- PARTICLE SYSTEM ---
        class ParticleSystem {
            constructor() {
                this.geometry = new THREE.BufferGeometry();
                this.count = config.particleCount;
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uSize: { value: 0.15 },
                        uColor: { value: config.baseColor },
                        uMorph: { value: 0.0 },
                        uNoiseStr: { value: config.noiseStrength },
                        uScale: { value: 1.0 },
                        uSpread: { value: 0.0 }
                    },
                    vertexShader, fragmentShader,
                    transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
                });
                this.initGeometry();
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
                this.isMorphing = false;
            }

            initGeometry() {
                const positions = new Float32Array(this.count * 3);
                const targets = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);
                const shapeFn = shapes.sphere;
                
                for (let i = 0; i < this.count; i++) {
                    const p = shapeFn(i, this.count);
                    positions[i*3] = targets[i*3] = p.x;
                    positions[i*3+1] = targets[i*3+1] = p.y;
                    positions[i*3+2] = targets[i*3+2] = p.z;
                    sizes[i] = Math.random() * 0.5 + 0.5;
                }
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targets, 3));
                this.geometry.setAttribute('pSize', new THREE.BufferAttribute(sizes, 1));
            }

            resize(newCount) {
                scene.remove(this.mesh);
                this.count = newCount;
                this.geometry.dispose();
                this.geometry = new THREE.BufferGeometry();
                this.initGeometry();
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
                this.changeShape(config.shape);
            }

            update(time) {
                this.material.uniforms.uTime.value = time;
                this.material.uniforms.uColor.value = config.baseColor;
                this.material.uniforms.uNoiseStr.value = config.noiseStrength;
                
                // Smoothly interpolate values from hand tracking
                this.material.uniforms.uScale.value = THREE.MathUtils.lerp(this.material.uniforms.uScale.value, config.handDistance, 0.1);
                this.material.uniforms.uSpread.value = THREE.MathUtils.lerp(this.material.uniforms.uSpread.value, config.handTension, 0.1);

                // Smooth rotation based on hand position
                if(config.handsDetected) {
                    this.mesh.rotation.y = THREE.MathUtils.lerp(this.mesh.rotation.y, config.handX, 0.05);
                    this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, config.handY, 0.05);
                } else {
                    this.mesh.rotation.y += 0.002; // Idle spin
                }

                if (this.isMorphing) {
                    const progress = (time - this.morphStartTime) / 1.5;
                    if (progress >= 1.0) {
                        this.material.uniforms.uMorph.value = 0.0;
                        this.isMorphing = false;
                        const pos = this.geometry.attributes.position;
                        pos.array.set(this.geometry.attributes.targetPosition.array);
                        pos.needsUpdate = true;
                    } else {
                        this.material.uniforms.uMorph.value = -(Math.cos(Math.PI * progress) - 1) / 2;
                    }
                }
            }

            changeShape(name) {
                if(!shapes[name]) return;
                config.shape = name;
                
                if(this.isMorphing) {
                    // finish current morph instantly
                    this.geometry.attributes.position.array.set(this.geometry.attributes.targetPosition.array);
                }

                const targets = this.geometry.attributes.targetPosition;
                const func = shapes[name];
                for(let i=0; i<this.count; i++) {
                    const p = func(i, this.count);
                    targets.array[i*3] = p.x;
                    targets.array[i*3+1] = p.y;
                    targets.array[i*3+2] = p.z;
                }
                targets.needsUpdate = true;
                this.isMorphing = true;
                this.morphStartTime = performance.now() / 1000;
            }
        }

        // --- SHAPE MATH ---
        const shapes = {
            sphere: (i, count) => {
                const r = 10;
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                return { x: r*Math.cos(theta)*Math.sin(phi), y: r*Math.sin(theta)*Math.sin(phi), z: r*Math.cos(phi) };
            },
            heart: (i, count) => {
                const r = 0.5;
                const u = Math.random()*Math.PI*2, v = Math.random()*Math.PI;
                let x = 16*Math.pow(Math.sin(u),3), y = 13*Math.cos(u)-5*Math.cos(2*u)-2*Math.cos(3*u)-Math.cos(4*u);
                return { x: x*r, y: y*r+2, z: 6*Math.cos(v)*Math.sin(u)*r };
            },
            flower: (i, count) => {
                const r = 12, theta = i * 2.39996;
                const rad = Math.sqrt(i)/Math.sqrt(count)*r;
                return { x: Math.cos(theta)*rad, y: Math.sin(theta)*rad, z: Math.sin(theta*5)*3*(1-rad/r) };
            },
            saturn: (i, count) => {
                if (i < count * 0.7) {
                    const r=6, phi=Math.acos(-1+(2*i)/(count*0.7)), theta=Math.sqrt(count*Math.PI)*phi;
                    return { x: r*Math.cos(theta)*Math.sin(phi), y: r*Math.sin(theta)*Math.sin(phi), z: r*Math.cos(phi) };
                }
                const r=8+Math.random()*6, a=Math.random()*6.28;
                return { x: Math.cos(a)*r, y: Math.sin(a)*r*0.1, z: Math.sin(a)*r };
            },
            buddha: (i, count) => {
                // Approximate meditating figure
                const p = Math.random();
                let x,y,z;
                if(p<0.25) { // Head
                   const r=2.5, u=Math.random()*6.28, v=Math.random()*3.14;
                   x=r*Math.sin(v)*Math.cos(u); y=r*Math.sin(v)*Math.sin(u)+6; z=r*Math.cos(v);
                } else if(p<0.6) { // Body
                   const r=4.5, u=Math.random()*6.28, v=Math.random()*3.14;
                   x=r*Math.sin(v)*Math.cos(u); y=r*Math.sin(v)*Math.sin(u); z=r*Math.cos(v)*0.8;
                } else { // Base
                   const r=7*Math.sqrt(Math.random()), a=Math.random()*6.28;
                   x=r*Math.cos(a); z=r*Math.sin(a); y=-4+Math.cos(a*2);
                }
                return {x,y,z};
            },
            fireworks: (i, count) => {
                const r = Math.pow(Math.random(), 0.5)*18, theta=Math.random()*6.28, phi=Math.acos(2*Math.random()-1);
                return { x: r*Math.sin(phi)*Math.cos(theta), y: r*Math.sin(phi)*Math.sin(theta), z: r*Math.cos(phi) };
            }
        };

        const particles = new ParticleSystem();

        // --- MEDIAPIPE LOGIC ---
        function onResults(results) {
            // Hide Loader
            loader.style.opacity = '0';
            setTimeout(() => loader.style.display = 'none', 500);

            // Debug Drawing
            outCanvas.width = videoElement.videoWidth || 640;
            outCanvas.height = videoElement.videoHeight || 480;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, outCanvas.width, outCanvas.height);
            canvasCtx.drawImage(results.image, 0, 0, outCanvas.width, outCanvas.height);

            const camStatus = document.getElementById('cam-status');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                config.handsDetected = true;
                camStatus.classList.add('active');

                // Draw skeleton on debug canvas
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
                    drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2});
                }

                const lm = results.multiHandLandmarks;

                // 1. Two Hands: Scale
                if (lm.length === 2) {
                    const d = Math.hypot(lm[0][0].x - lm[1][0].x, lm[0][0].y - lm[1][0].y);
                    config.handDistance = THREE.MathUtils.mapLinear(d, 0.2, 0.7, 0.5, 2.5);
                }

                // 2. One Hand: Rotate & Tension
                const hand = lm[0];
                const wrist = hand[0];
                
                // Map hand position to rotation (Center is 0.5)
                config.handX = (wrist.x - 0.5) * -4; 
                config.handY = (wrist.y - 0.5) * -4;

                // Tension (Fist vs Open)
                const tips = [8,12,16,20];
                let avgDist = 0;
                tips.forEach(i => avgDist += Math.hypot(hand[i].x - wrist.x, hand[i].y - wrist.y));
                avgDist /= 4;

                if(avgDist < 0.2) config.handTension = -0.8; // Fist
                else if(avgDist > 0.35) config.handTension = 1.0; // Open
                else config.handTension = 0.0;

            } else {
                camStatus.classList.remove('active');
                config.handsDetected = false;
                config.handDistance = 1.0;
                config.handTension = 0.0;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraFeed.start();

        // --- EVENTS ---
        document.querySelectorAll('.shape-btn').forEach(b => b.onclick = (e) => {
            document.querySelectorAll('.shape-btn').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            particles.changeShape(e.target.dataset.shape);
        });

        document.getElementById('particle-count').oninput = (e) => {
            config.particleCount = +e.target.value;
            document.getElementById('count-val').innerText = (config.particleCount/1000).toFixed(0)+'k';
            particles.resize(config.particleCount);
        };
        document.getElementById('noise-str').oninput = (e) => config.noiseStrength = +e.target.value;
        document.getElementById('color-picker').oninput = (e) => config.baseColor = new THREE.Color(e.target.value);
        document.getElementById('snap-btn').onclick = () => {
            renderer.render(scene, camera);
            const a = document.createElement('a');
            a.download = 'particles.png';
            a.href = renderer.domElement.toDataURL();
            a.click();
        };

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };

        // Fallback Mouse
        document.onmousemove = (e) => {
            if(!config.handsDetected) {
                particles.mesh.rotation.y = (e.clientX - window.innerWidth/2) * 0.001;
                particles.mesh.rotation.x = (e.clientY - window.innerHeight/2) * 0.001;
            }
        };

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            particles.update(performance.now() / 1000);
            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>